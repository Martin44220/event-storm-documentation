"use strict";(self.webpackChunkevent_storm_documentation=self.webpackChunkevent_storm_documentation||[]).push([[692],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,g=m["".concat(i,".").concat(u)]||m[u]||d[u]||o;return n?a.createElement(g,s(s({ref:t},c),{},{components:n})):a.createElement(g,s({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=m;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7305:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={id:"api-reference-overview",title:"API Overview",tags:["api","api-reference"],sidebar_position:1},s=void 0,l={unversionedId:"api-reference/api-reference-overview",id:"api-reference/api-reference-overview",title:"API Overview",description:"API (TODO:: update the API section)",source:"@site/docs/api-reference/overview.md",sourceDirName:"api-reference",slug:"/api-reference/api-reference-overview",permalink:"/docs/api-reference/api-reference-overview",draft:!1,editUrl:"https://github.com/event-storm/event-storm-documentation/tree/main/api-reference/overview.md",tags:[{label:"api",permalink:"/docs/tags/api"},{label:"api-reference",permalink:"/docs/tags/api-reference"}],version:"current",sidebarPosition:1,frontMatter:{id:"api-reference-overview",title:"API Overview",tags:["api","api-reference"],sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"API reference",permalink:"/docs/category/api-reference"}},i={},p=[{value:"API (TODO:: update the API section)",id:"api-todo-update-the-api-section",level:2},{value:"Playground",id:"playground",level:2}],c={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"api-todo-update-the-api-section"},"API (TODO:: update the API section)"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Store\n",(0,r.kt)("strong",{parentName:"p"},"Creating a store")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nconsole.log(store.getState()) // { taxes: 20, grossSalary: 100_000 }\n\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Updating the store information")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\nstore.dispatch({ taxes: 100 });\nconsole.log(store.getState()); // { taxes: 100, grossSalary: 200_000 }\n\nstore.dispatch({ taxes: 150, grossSalary: 300_000 });\nconsole.log(store.getState()); // { taxes: 150, grossSalary: 300_000 }\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Subscribe/unsubscribe to store changes")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { createStorm } from \'event-storm\';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n// the third argument will be discussed earlier\nconst subscription = store.subscribe((key, nextValue, model) => {\n  console.log(key, nextValue, model); // "taxes" "100" ModelObject\n});\n\nstore.dispatch({ taxes: 100 });\n\nsubscription();\n\nstore.dispatch({ taxes: 70 }); // the handler will not be fired\n')),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Deriving a state in the store")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n  netSalary: ({ taxes, grossSalary }) => grossSalary * (100 - taxes) / 100,\n});\n\nconsole.log(store.getState().netSalary); // 80_000\n\nstore.dispatch({ taxes: 40 });\n\nconsole.log(store.getState().netSalary); // 60_000\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Advanced store usage"),'\nAs mentioned above the store is decentralized. Any piece of information can be also used independently from the store. The peace of information is called the "model". When creating a store, under the hood it creates "models".'),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Accessing the models")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nconst {\n  taxes: taxesModel,\n  grossSalary: grossSalaryModel,\n} = store.models;\n")),(0,r.kt)("p",{parentName:"li"},"As mentioned above you can use the models independently. Each model will give:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"an access to last state"),(0,r.kt)("li",{parentName:"ul"},"a subscription"),(0,r.kt)("li",{parentName:"ul"},"own dispatchment method")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nconst { taxes: taxesModel } = store.models;\n\nconsole.log(taxes.getState()); // 20;\n\ntaxes.dispatch(40);\n\ntaxes.subscribe(nextValue => {\n  console.log(nextValue); // 40\n});\n\nconsole.log(taxes.getState()); // 40;\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Functional dispatch"),".\nUpdating the store may require having the store's previous state. For that purpose you can use the following:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nstore.dispatch(prevState => ({\n  ...prevState\n  taxes: prevState.taxes + 10,\n}));\n\nconsole.log(store.getState()); // { taxes: 30, grossSalary: 100_000 }\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Asynchronous dispatch"),"\nFor asynchronous events, it's also possible to ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," the dispatch process"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\nawait store.dispatch(async prevState => {\n  const promise = Promise.resolve().then(() => ({\n    ...prevState\n    taxes: prevState.taxes + 10,\n  }));\n  const result = await promise;\n  // Some stuff after async operation is done;\n  return result;\n});\n\n// some stuff after the store dispatch is done on async operation\nconsole.log(store.getState()); // { taxes: 30, grossSalary: 100_000 }\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Creating a model manually(source of truth)\n",(0,r.kt)("strong",{parentName:"p"},"createModel")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createModel } from 'event-storm';\n\nconst userModel = createModel();\n// When defining a model it is often usefull to have a **default value**:\nconst clientModel = createModel({});\n\n/* NOT RECOMMENDED!\n You can also pass the second parameter to `createModel`, which will make the model propagate on duplicate changes. Most likely if the code depends on the duplicated event it needs to be refactored,\n instead of firing the same event twice.\n*/\n\nconst anyModel = createModel({}, { fireDuplicates: true });\n")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Model API")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const popupModel = createModel(true);\n\nconst subscription = popupModel.subscribe(nextValue => {\n  console.log(nextValue); // false\n});\n")))),(0,r.kt)("p",null,"  /",(0,r.kt)("em",{parentName:"p"}," As mentioned above the API is the same.\nIt's possible to make a functional and asynchronous dispatch process for a single model.\n"),"/\npopupModel.dispatch(false);"),(0,r.kt)("p",null,"  console.log(popupModel.getState()); // false"),(0,r.kt)("p",null,"  subscription();"),(0,r.kt)("p",null,"  popupModel.dispatch(false); // the callback will not be fired"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"- Model API with state derivation\n**createVirtualModel**\nThe example above will show how to create a new model based on existing models.\n**Creating a model from existing ones will allow you to create some shared state which you want also to\nlisten**. Both functions `createModel` and `createVirtualModel` will return you the same result(a model),\nwhich will be a subject to subscribe. NOTE, for both cases the API remains exactly the same.\n```typescript\nimport { createModel, createVirtualModel } from 'event-storm';\n// real models\nconst time = createModel(0);\nconst velocity = createModel(10);\n\n// virtual model\nconst road = createVirtualModel(() => {\n  return time.getState() * velocity.getState();\n}, { models: [time, velocity] });\n\nroad.subscribe(nextValue => {\n  console.log(nextValue); // 10\n});\n\ntime.dispatch(1);\n")),(0,r.kt)("p",null,"  The second argument is responsible for updates. Whenever any provided model is updated, the handler function will be triggered.\nThis will also cause the subscribers update."),(0,r.kt)("p",null,"  Advanced!"),(0,r.kt)("p",null,"  Pay attention to the virtual model's declaration. The 2nd argument is the configuration,\nwhich can be skipped initially.\nThis is done for cases when you want to propagate changes depend on some condition.\nYou can always change the models which you want to listen. Just call:\nvirtualModel.setOptions({ models: ","[/",(0,r.kt)("em",{parentName:"p"}," any models here "),"/]"," })"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Middlewares\n",(0,r.kt)("strong",{parentName:"p"},"Middlewares are needed to intercept to dispatching process, to capture some values")),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { addMiddlewares, createStorm } from 'event-storm';\n\nconst store = createStorm({\n  taxes: 20,\n  grossSalary: 100_000,\n});\n\naddMiddlewares(store.models)((prevValue, nextValue) => {\n  // some stuff\n});\n/* Also, the method supports multiples middlewares addition at once.\n  addMiddlewares(store)(handler1, handler2, ..., handlerN);\n*/\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Store Persistence\nYou can easly make your store any segment to be persisted by ",(0,r.kt)("inlineCode",{parentName:"p"},"persisted")," function."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm, persisted } from 'event-storm';\n\nconst createPersistedStore = persisted(createStorm)({\n  storageKey: 'some_store_key',\n  beforeunload: state => ({\n    users: state.users,\n  }),\n});\n\nconst defaultState = {\n  users: [],\n  age: 15,\n  loading: false,\n};\n\nconst store = createPersistedStore(defaultState);\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"storageKey")," is ",(0,r.kt)("strong",{parentName:"p"},"required property"),". It will specify where to keep the persisted data in the storage.\n",(0,r.kt)("inlineCode",{parentName:"p"},"beforeunload")," method is called right before the browser unload event. It will receive the current store state as an argument.\nIt can return any store fragment as a return value. The return value will be persisted."),(0,r.kt)("p",null,"By default the ",(0,r.kt)("inlineCode",{parentName:"p"},"sessionStorage")," is used to store the persisted data. To change the storage to ",(0,r.kt)("inlineCode",{parentName:"p"},"localStorage")," you can set the\n",(0,r.kt)("inlineCode",{parentName:"p"},"permanent")," property to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { createStorm, persisted } from 'event-storm';\n\nconst createPersistedStore = persisted(createStorm)({\n  permanent: true,\n  storageKey: 'some_store_key',\n  beforeunload: state => ({\n    users: state.users,\n  }),\n});\n\nconst defaultState = {\n  users: [],\n  age: 15,\n  loading: false,\n};\n\nconst store = createPersistedStore(defaultState);\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Log for development\nThe library is outputing logs when ",(0,r.kt)("strong",{parentName:"li"},"NODE_ENV")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"'development'"),". To disable this log you can simply do this:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { configure } from 'event-storm';\n\nconfigure({ needLogs: false });\n")),(0,r.kt)("h2",{id:"playground"},"Playground"),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codesandbox.io/s/beautiful-currying-bl9dv"},(0,r.kt)("strong",{parentName:"a"},"Typescript"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://codesandbox.io/s/intelligent-http-iupz5"},(0,r.kt)("strong",{parentName:"a"},"React")))))}d.isMDXComponent=!0}}]);